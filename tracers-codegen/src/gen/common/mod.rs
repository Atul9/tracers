//! This module contains some code which is shared between the different code generation
//! implementations.  It does not contain a working code generator implementation itself.
use crate::spec::ProbeSpecification;
use crate::spec::ProviderSpecification;
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};

/// Generates the an additional doc comment for the generated provider trait/struct/whatever, which
/// provides some helpful information about how to use that provider with the various tracing
/// platforms.  This way callers can simply generate docs on their own crates and get help with
/// tracing.
pub(super) fn generate_trait_comment(provider: &ProviderSpecification) -> TokenStream {
    let comment = format!(
        r###"
# Probing

This trait is translated at compile-time by `tracers` into a platform-specific tracing
provider, which allows very high-performance and low-overhead tracing of the probes it
fires.

The exact details of how to use interact with the probes depends on the underlying
probing implementation.

## SystemTap/USDT (Linux x64)

This trait corresponds to a SystemTap/USDT provider named `{provider_name}`,

## Other platforms

TODO: No other platforms supported yet
"###,
        provider_name = provider.name()
    );

    generate_multiline_comments(&comment)
}

/// Generates the declaration (but *NOT* the *implementation*) of the `__try_init_provider` method.
/// This includes a detailed doc comment.  Each generator must implement this method, but this
/// generates the declaration, looking something like this:
///
/// ```no_execute
/// #[allow(dead_code)]
/// #vis fn __try_init_provider() -> Option<&'static ::tracers::runtime::failure::Error>
/// ```
///
/// The actual generator should insert this token stream in the generated trait/struct, followed by
/// an implementation contained in `{}` chars
pub(super) fn generate_try_init_decl(provider: &ProviderSpecification) -> TokenStream {
    let vis = &provider.item_trait().vis;

    quote! {
        /// **NOTE**: This function was generated by the `tracers` macro
        ///
        /// Initializes the provider, if it isn't already initialized, and if initialization
        /// failed returns the error.
        ///
        /// # Usage
        ///
        /// Initializing the provider is not required.  By default, each provider will lazily
        /// initialize the first time a probe is fired.  Explicit initialization can be useful
        /// because it ensures that all of a provider's probes are registered and visible to
        /// the platform-specific tracing tools, like `bpftrace` or `tplist` on Linux.
        ///
        /// It's ok to initialize a provider more than once; init operations are idempotent and
        /// if repeated will not do anything
        ///
        /// # Caution
        ///
        /// Callers should not call this method directly.  Instead use the provided
        /// `init_provider!` macro.  This will correctly elide the call when probing is
        /// compile-time disabled.
        ///
        /// # Example
        ///
        /// ```
        /// use tracers_macros::{init_provider, tracer, probe};
        ///
        /// #[tracer]
        /// trait MyProbes {
        ///     fn probe0();
        /// }
        ///
        /// if let Some(err) = init_provider!(MyProbes) {
        ///     eprintln!("Probe provider failed to initialize: {}", err);
        /// }
        ///
        /// //Note that even if the provider fails to initialize, firing probes will never fail
        /// //or panic...
        ///
        /// println!("Firing anyway...");
        /// probe!(MyProbes::probe0());
        /// ```
        #[allow(dead_code)]
        #vis fn __try_init_provider() -> Option<&'static ::tracers::runtime::failure::Error>
    }
}

/// Generates the declaration (but *NOT* the *implementation*) of the `__get_init_error` method.
/// This includes a detailed doc comment.  Each generator must implement this method, but this
/// generates the declaration, looking something like this:
///
/// ```no_execute
/// #[allow(dead_code)]
/// #vis fn __get_init_error() -> Option<&'static ::tracers::runtime::failure::Error>
/// ```
///
/// The actual generator should insert this token stream in the generated trait/struct, followed by
/// an implementation contained in `{}` chars
pub(super) fn generate_get_init_error_decl(provider: &ProviderSpecification) -> TokenStream {
    let vis = &provider.item_trait().vis;

    quote! {
        /// **NOTE**: This function was generated by the `tracers` macro
        ///
        /// If the provider has been initialized, and if that initialization failed, this
        /// method returns the error information.  If the provider was not initialized, this
        /// method does not initialize it.
        ///
        /// # Usage
        ///
        /// In general callers should prefer to use the `init_provider!` macro which wraps a
        /// call to `__try_init_provider`.  Calls to `get_init_error()` directly are necessary
        /// only when the caller specifically wants to avoid triggering initialization of the
        /// provider, but merely to test if initialization was attempted and failed previously.
        #[allow(dead_code)]
        #vis fn __get_init_error() -> Option<&'static ::tracers::runtime::failure::Error>
    }
}

/// Generates the `#[deprecated...]` attribute which triggers a warning if anyone tries to call the
/// probe method directly, not through the `probe!` attribute
pub(super) fn generate_probe_deprecation_attribute(
    provider: &ProviderSpecification,
    probe: &ProbeSpecification,
) -> TokenStream {
    let deprecation_message = format!( "Probe methods should not be called directly.  Use the `probe!` macro, e.g. `probe!({}::{}(...))`",
            provider.item_trait().ident,
            probe.method_name);
    let span = probe.method_name.span();

    quote_spanned! {span=>
        #[deprecated(note = #deprecation_message)]
    }
}

/// Generates a doc comment to attach to the probe's method.  This includes additional information
/// about how to work with this probe on various platforms.
pub(super) fn generate_probe_doc_comment(
    provider: &ProviderSpecification,
    probe: &ProbeSpecification,
) -> TokenStream {
    let probe_comment = format!(r###"
# Probing

This method is translated at compile-time by `tracers` into a platform-specific tracing
probe, which allows very high-performance and low-overhead tracing.

## How to fire probe

To fire this probe, don't call this method directly. Instead, use the `probe!` macro, for example:

```ignore
// If the probe is enabled, fires the probe.  If the probe isn't enabled, or if provider
// initialization failed for some reason, does not fire the probe, and does NOT evaluate the
// arguments to the probe.
probe!({trait_name}::{probe_name}(...));
```

The exact details of how to interact with the probes depends on the underlying
probing implementation.

## SystemTap/USDT (Linux x64)

To trace the firing of this probe, use `bpftrace`, e.g.:
```text
sudo bpftrace -p ${{PID}} -e 'usdt::{provider}:{probe_name} {{ printf("Hello from {probe_name}\n"); }}'
```

where `${{PID}}` should be the actual process ID of the process you are tracing.

## Other platforms

TODO: No other platforms supported yet

"###,
        trait_name = &provider.item_trait().ident,
        probe_name = &probe.name,
        provider = provider.name(),
);

    generate_multiline_comments(&probe_comment)
}

/// When generating a comment with `#[doc]` if the string is multi-lined then `quote_spanned` seems
/// to get confused and puts the rest of the lines of the string in a separate token tree.
/// This method simply takes a multi-line string literal, breaks it up into separate lines, and
/// generates one `#[doc...]` comment per line
fn generate_multiline_comments(comment: &str) -> TokenStream {
    let lines = comment.lines().map(|line| {
        let with_leading_space = format!(" {}", line);
        quote! {
            #[doc = #with_leading_space]
        }
    });

    quote! {
        #(#lines)*
    }
}
