//! Code in this module processes the provider trait decorated with the `probers` attribute, and
//!replaces it with an implementation using libstapsdt.
use crate::probe::ProbeSpecification;
use crate::provider::ProviderSpecification;
use crate::syn_helpers;
use crate::{ProberError, ProberResult};
use heck::{ShoutySnakeCase, SnakeCase};
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};
use std::borrow::BorrowMut;
use std::fmt::Display;
use syn::parse_quote;
use syn::spanned::Spanned;
use syn::{Ident, ItemTrait};

pub(super) struct ProviderTraitGenerator<'spec> {
    spec: &'spec ProviderSpecification,
    probes: Vec<ProbeGenerator<'spec>>,
}

impl<'spec> ProviderTraitGenerator<'spec> {
    pub fn new(spec: &'spec ProviderSpecification) -> ProviderTraitGenerator<'spec> {
        let probes: Vec<_> = spec
            .probes()
            .iter()
            .map(|pspec| ProbeGenerator::new(pspec))
            .collect();
        ProviderTraitGenerator { spec, probes }
    }

    pub fn generate(&self) -> ProberResult<TokenStream> {
        // Re-generate this trait as a struct with our probing implementation in it
        let prober_struct = self.generate_prober_struct()?;

        // Generate code for a struct and some `OnceCell` statics to hold the instance of the provider
        // and individual probe wrappers
        let impl_mod = self.generate_impl_mod();

        Ok(quote_spanned! { self.spec.item_trait().span() =>
            #prober_struct

            #impl_mod
        })
    }
    /// A provider is described by the user as a `trait`, with methods corresponding to probes.
    /// However it's actually implemented as a `struct` with no member fields, with static methods
    /// implementing the probes.  Thus, given as input the `trait`, we produce a `struct` of the same
    /// name whose implementation actually performs the firing of the probes.
    fn generate_prober_struct(&self) -> ProberResult<TokenStream> {
        // From the probe specifications, generate the corresponding methods that will be on the probe
        // struct.
        let mut probe_methods: Vec<TokenStream> = Vec::new();
        let mod_name = self.get_provider_impl_mod_name();
        let struct_type_name = self.get_provider_impl_struct_type_name();
        let struct_type_path: syn::Path = parse_quote! { #mod_name::#struct_type_name };
        let provider_name = self.spec.name();
        for probe in self.probes.iter() {
            probe_methods.push(probe.generate_trait_methods(
                &self.spec.item_trait().ident,
                &provider_name,
                &struct_type_path,
            )?);
        }

        // Re-generate the trait method that we took as input, with the modifications to support
        // probing
        // This includes constructing documentation for this trait, using whatever doc strings are already applied by
        // the user, plus a section of our own that has information about the provider and how it
        // translates into the various implementations.
        //
        // Hence, the rather awkward `#[doc...]` bits

        let attrs = &self.spec.item_trait().attrs;
        let span = self.spec.item_trait().span();
        let ident = &self.spec.item_trait().ident;
        let vis = &self.spec.item_trait().vis;

        let mod_name = self.get_provider_impl_mod_name();
        let struct_type_name = self.get_provider_impl_struct_type_name();
        let systemtap_comment = format!(
            "This trait corresponds to a SystemTap/USDT provider named `{}`",
            provider_name
        );

        let result = quote_spanned! { span =>
            #(#attrs)*
            #[doc = "# Probing

This trait is translated at compile-time by `probers` into a platform-specific tracing
provider, which allows very high-performance and low-overhead tracing of the probes it
fires.

The exact details of how to use interact with the probes depends on the underlying
probing implementation.

## SystemTap/USDT (Linux x64)
"]
            #[doc = #systemtap_comment]
            #[doc ="
## Other platforms

TODO: No other platforms supported yet
"]
            #vis struct #ident;

            impl #ident {
                #(#probe_methods)*

                /// **NOTE**: This function was generated by the `probers` macro
                ///
                /// Initializes the provider, if it isn't already initialized, and if initialization
                /// failed returns the error.
                ///
                /// # Usage
                ///
                /// Initializing the provider is not required.  By default, each provider will lazily
                /// initialize the first time a probe is fired.  Explicit initialization can be useful
                /// because it ensures that all of a provider's probes are registered and visible to
                /// the platform-specific tracing tools, like `bpftrace` or `tplist` on Linux.
                ///
                /// It's ok to initialize a provider more than once; init operations are idempotent and
                /// if repeated will not do anything
                ///
                /// # Caution
                ///
                /// Callers should not call this method directly.  Instead use the provided
                /// `init_provider!` macro.  This will correctly elide the call when probing is
                /// compile-time disabled.
                ///
                /// # Example
                ///
                /// ```
                /// use probers::{init_provider, prober, probe};
                ///
                /// #[prober]
                /// trait MyProbes {
                ///     fn probe0();
                /// }
                ///
                /// if let Some(err) = init_provider!(MyProbes) {
                ///     eprintln!("Probe provider failed to initialize: {}", err);
                /// }
                ///
                /// //Note that even if the provider fails to initialize, firing probes will never fail
                /// //or panic...
                ///
                /// println!("Firing anyway...");
                /// probe!(MyProbes::probe0());
                /// ```
                #[allow(dead_code)]
                #vis fn __try_init_provider() -> Option<&'static ::probers::failure::Error> {
                    #mod_name::#struct_type_name::get();
                    #mod_name::#struct_type_name::get_init_error()
                }

                /// **NOTE**: This function was generated by the `probers` macro
                ///
                /// If the provider has been initialized, and if that initialization failed, this
                /// method returns the error information.  If the provider was not initialized, this
                /// method does not initialize it.
                ///
                /// # Usage
                ///
                /// In general callers should prefer to use the `init_provider!` macro which wraps a
                /// call to `__try_init_provider`.  Calls to `get_init_error()` directly are necessary
                /// only when the caller specifically wants to avoid triggering initialization of the
                /// provider, but merely to test if initialization was attempted and failed previously.
                #[allow(dead_code)]
                #vis fn __get_init_error() -> Option<&'static ::probers::failure::Error> {
                    #mod_name::#struct_type_name::get_init_error()
                }
            }
        };

        Ok(result)
    }

    /// The implementation of the probing logic is complex enough that it involves the declaration of a
    /// few variables and one new struct type.  All of this is contained within a module, to avoid the
    /// possibility of collissions with other code.  This method generates that module and all its
    /// contents.
    ///
    /// The contents are, briefly:
    /// * The module itself, named after the trait
    /// * A declaration of a `struct` which will hold references to all of the probes
    /// * Multiple static `OnceCell` variables which hold the underlying provider instance as well as
    /// the instance of the `struct` which holds references to all of the probes
    fn generate_impl_mod(&self) -> TokenStream {
        let mod_name = self.get_provider_impl_mod_name();
        let struct_type_name = self.get_provider_impl_struct_type_name();
        let struct_var_name = self.get_provider_impl_struct_var_name();
        let struct_type_params = self.generate_provider_struct_type_params();
        let instance_var_name = self.get_provider_instance_var_name();
        let define_provider_call = self.generate_define_provider_call();
        let provider_var_name = syn::Ident::new("p", self.spec.item_trait().span());
        let struct_members: Vec<_> = self
            .probes
            .iter()
            .map(|probe| probe.generate_struct_member_declaration())
            .collect();

        let struct_initializers: Vec<_> = self
            .probes
            .iter()
            .map(|probe| probe.generate_struct_member_initialization(&provider_var_name))
            .collect();

        quote_spanned! { self.spec.item_trait().span() =>
            mod #mod_name {
                use ::probers::failure::{bail, Fallible};
                use ::probers::{SystemTracer,SystemProvider,Provider};
                use ::probers::{ProviderBuilder,Tracer};
                use ::probers::once_cell::sync::OnceCell;

                #[allow(dead_code)]
                pub(super) struct #struct_type_name<#struct_type_params> {
                    #(pub #struct_members),*
                }

                unsafe impl<#struct_type_params> Send for #struct_type_name<#struct_type_params> {}
                unsafe impl<#struct_type_params> Sync for #struct_type_name <#struct_type_params>{}

                static #instance_var_name: OnceCell<Fallible<SystemProvider>> = OnceCell::INIT;
                static #struct_var_name: OnceCell<Fallible<#struct_type_name>> = OnceCell::INIT;
                static IMPL_OPT: OnceCell<Option<&'static #struct_type_name>> = OnceCell::INIT;

                impl<#struct_type_params> #struct_type_name<#struct_type_params> {
                   pub(super) fn get_init_error() -> Option<&'static failure::Error> {
                        //Don't do a whole re-init cycle again, but if the initialization has happened,
                        //check for failure
                        #struct_var_name.get().and_then(|fallible|  fallible.as_ref().err() )
                   }

                   #[allow(dead_code)]
                   pub(super) fn get() -> Option<&'static #struct_type_name<#struct_type_params>> {
                       let imp: &'static Option<&'static #struct_type_name> = IMPL_OPT.get_or_init(|| {
                           // The reason for this seemingly-excessive nesting is that it's possible for
                           // both the creation of `SystemProvider` or the subsequent initialization of
                           // #struct_type_name to fail with different and also relevant errors.  By
                           // separting them this way we're able to preserve the details about any init
                           // failures that happen, while at runtime when firing probes it's a simple
                           // call of a method on an `Option<T>`.  I don't have any data to back this
                           // up but I suspect that allows for better optimizations, since we know an
                           // `Option<&T>` is implemented as a simple pointer where `None` is `NULL`.
                           let imp = #struct_var_name.get_or_init(|| {
                               // Initialzie the `SystemProvider`, capturing any initialization errors
                               let #provider_var_name: &Fallible<SystemProvider> = #instance_var_name.get_or_init(|| {
                                    #define_provider_call
                               });

                               // Transform this #provider_var_name into an owned `Fallible` containing
                               // references to `T` or `E`, since there's not much useful you can do
                               // with just a `&Result`.
                               match #provider_var_name.as_ref() {
                                   Err(e) => bail!("Provider initialization failed: {}", e),
                                   Ok(#provider_var_name) => {
                                       // Proceed to create the struct containing each of the probes'
                                       // `ProviderProbe` instances
                                       Ok(
                                           #struct_type_name{
                                               #(#struct_initializers,)*
                                           }
                                       )
                                   }
                               }
                           });

                           //Convert this &Fallible<..> into an Option<&T>
                           imp.as_ref().ok()
                       });

                       //Copy this `&Option<&T>` to a new `Option<&T>`.  Since that should be
                       //implemented as just a pointer, this should be effectively free
                       *imp
                   }
                }
            }
        }
    }

    /// A `Provider` is built by calling `define_provider` on a `Tracer` implementation.
    /// `define_provider` takes a closure and passes a `ProviderBuilder` parameter to that closure.
    /// This method generates the call to `SystemTracer::define_provider`, and includes code to add
    /// each of the probes to the provider
    fn generate_define_provider_call(&self) -> TokenStream {
        let builder = syn::Ident::new("builder", self.spec.item_trait().ident.span());
        let add_probe_calls: Vec<TokenStream> = self
            .probes
            .iter()
            .map(|probe| probe.generate_add_probe_call(&builder))
            .collect();
        let provider_name = self.spec.name();

        quote_spanned! { self.spec.item_trait().span() =>
            // The provider name must be chosen carefully.  As of this writing (2019-04) the `bpftrace`
            // and `bcc` tools have, shall we say, "evolving" support for USDT.  As of now, with the
            // latest git version of `bpftrace`, the provider name can't have dots or colons.  For now,
            // then, the provider name is just the name of the provider trait, converted into
            // snake_case for consistency with USDT naming conventions.  If two modules in the same
            // process have the same provider name, they will conflict and some unspecified `bad
            // things` will happen.
            let provider_name = #provider_name;

            SystemTracer::define_provider(&provider_name, |mut #builder| {
                #(#add_probe_calls)*

                Ok(builder)
            })
        }
    }

    /// The provider struct we declare to hold the probe objects needs to take a lot of type
    /// parameters.  One type, 'a, which corresponds to the lifetime parameter of the underling
    /// `ProviderProbe`s, and also one lifetime parameter for every reference argument of every probe
    /// method.
    ///
    /// The return value of this is a token stream consisting of all of the types, but not including
    /// the angle brackets.
    fn generate_provider_struct_type_params(&self) -> TokenStream {
        // Make a list of all of the reference param lifetimes of all the probes
        let probe_lifetimes: Vec<syn::Lifetime> = self
            .probes
            .iter()
            .map(|p| p.args_lifetime_parameters())
            .flatten()
            .collect();

        //The struct simply takes all of these lifetimes plus 'a
        quote! {
            'a, #(#probe_lifetimes),*
        }
    }

    /// Returns the name of the module in which most of the implementation code for this trait will be
    /// located.
    fn get_provider_impl_mod_name(&self) -> syn::Ident {
        let snake_case_name = format!("{}Provider", self.spec.item_trait().ident).to_snake_case();

        syn::Ident::new(
            &format!("__{}", snake_case_name),
            self.spec.item_trait().ident.span(),
        )
    }

    /// The name of the struct type within the impl module which represents the provider, eg `MyProbesProviderImpl`.
    /// Note that this is not the same as the struct which we generate which has the same name as the
    /// trait and implements its methods.
    fn get_provider_impl_struct_type_name(&self) -> syn::Ident {
        crate::syn_helpers::add_suffix_to_ident(&self.spec.item_trait().ident, "ProviderImpl")
    }

    /// The name of the static variable which contains the singleton instance of the provider struct,
    /// eg MYPROBESPROVIDERIMPL
    fn get_provider_impl_struct_var_name(&self) -> syn::Ident {
        syn::Ident::new(
            &format!("{}ProviderImpl", self.spec.item_trait().ident).to_shouty_snake_case(),
            self.spec.item_trait().span(),
        )
    }

    /// The name of the static variable which contains the singleton instance of the underlying tracing
    /// system's `Provider` instance, eg MYPROBESPROVIDER
    fn get_provider_instance_var_name(&self) -> syn::Ident {
        syn::Ident::new(
            &format!("{}Provider", self.spec.item_trait().ident).to_shouty_snake_case(),
            self.spec.item_trait().span(),
        )
    }
}

pub(super) struct ProbeGenerator<'spec> {
    spec: &'spec ProbeSpecification,
}

impl<'spec> ProbeGenerator<'spec> {
    pub fn new(spec: &'spec ProbeSpecification) -> ProbeGenerator<'spec> {
        ProbeGenerator { spec }
    }

    /// The name of the variable in the implementation struct which will hold this particular
    /// probe's `ProviderProbe` wrapper object
    pub(crate) fn probe_var_name(&self) -> &Ident {
        &self.spec.method_name
    }

    /// For each probe the user defines on the trait, we will generate multiple implementation
    /// methods:
    ///
    /// * `(probe_name)` - This is the same name as the method the user declared.  It takes the same
    /// arguments the user specified, and when called it checks to see if the probe is enabled and
    /// if so fires the probe.  This is implemented as a normal Rust function call, so the
    /// arguments to the probe function are evaluated unconditionally, whether the probe is enabled
    /// or not.
    /// * `(probe_name)_is_enabled` - This takes no args and returns a `bool` indicating if the
    /// probe is enabled or not.  Most situations won't require this method, but in some rare cases
    /// where some specific operation is conditional upon the enabling of a specific probe, this is
    /// available.
    /// * `if_(probe_name)_enabled` - This is a more complex version of `(probe_name)_is_enabled`
    /// which takes as an argument a `FnOnce` closure, which itself is passed a `FnOnce` closure
    /// which when called will fire the probe.  If the probe is not enabled, this closure never
    /// gets called.  Thus, in this way callers can implement potentially expensive logic to
    /// prepare information for a probe, and only run this code when the probe is activated.
    pub fn generate_trait_methods(
        &self,
        trait_name: &syn::Ident,
        provider_name: &str,
        struct_type_path: &syn::Path,
    ) -> ProberResult<TokenStream> {
        let vis = &self.spec.vis;
        //The original method will be implemented as a call to the impl method.  It's only purpose
        //is to ensure the user can call the original method and get our warning reminding them ot
        //use the `probe!` macro instead.  Otherwise it would be confusing to not be able to call a
        //method they think should exist on a trait they themselves defined, even if doing so is
        //not the intended use of this crate.
        let original_method = self.spec.original_method.sig.clone();

        //Generate an _enabled method which tests if this probe is enabled at runtime
        let mut enabled_method = original_method.clone();
        enabled_method.ident = syn_helpers::add_suffix_to_ident(&enabled_method.ident, "_enabled");
        enabled_method.decl.inputs = syn::punctuated::Punctuated::new();
        enabled_method.decl.output = syn::ReturnType::Default;

        //Generate an (probe)_probe method which returns the raw Option<ProviderProbe>
        let mut probe_method = original_method.clone();
        probe_method.ident = Ident::new(
            &format!("get_{}_probe", probe_method.ident),
            probe_method.ident.span(),
        );
        probe_method.decl.inputs = syn::punctuated::Punctuated::new();
        probe_method.decl.output = syn::ReturnType::Default;
        let probe_method_ret_type = self.generate_provider_probe_type();
        let a_lifetime = syn::Lifetime::new("'a", self.spec.span);
        probe_method
            .decl
            .generics
            .params
            .push(syn::GenericParam::Lifetime(syn::LifetimeDef::new(
                a_lifetime,
            )));
        for param in self.args_lifetime_parameters().iter() {
            probe_method
                .decl
                .generics
                .params
                .push(syn::GenericParam::Lifetime(syn::LifetimeDef::new(
                    param.clone(),
                )))
        }

        //Generate an _impl method that actually fires the probe when called
        let mut impl_method = original_method.clone();
        impl_method.ident = syn_helpers::add_suffix_to_ident(&impl_method.ident, "_impl");

        //Generate the body of the original method, simply passing its arguments directly to the
        //impl method
        let probe_args_tuple = self.args_as_tuple_value();

        //Keep the original probe method, but mark it deprecated with a helpful message so that if the
        //user calls the probe method directly they will at least be reminded that they should use the
        //macro instead.
        let probe_name = &self.spec.name;
        let probe_ident = &self.spec.method_name;
        let deprecation_message = format!( "Probe methods should not be called directly.  Use the `probe!` macro, e.g. `probe!({}::{}(...))`",
            trait_name,
            probe_name);

        //Keep any attributes that were on the original method, and add `doc` attributes at the end
        //to provide some more information about the generated probe mechanics
        let attrs = &self.spec.original_method.attrs;
        let probe_fire_comment = format!(
            r###"
To fire this probe, don't call this method directly. Instead, use the `probe!` macro, for example:

```ignore
// If the probe is enabled, fires the probe.  If the probe isn't enabled, or if provider
// initialization failed for some reason, does not fire the probe, and does NOT evaluate the
// arguments to the probe.
probe!({trait_name}::{probe_name}(...));
```
"###,
            trait_name = trait_name,
            probe_name = probe_name
        );
        let systemtap_comment = format!(
            r###"
To trace the firing of this probe, use `bpftrace`, e.g.:
```text
sudo bpftrace -p ${{PID}} -e 'usdt::{provider}:{probe} {{ printf("Hello from {probe}\n"); }}'
```

where `${{PID}}` should be the actual process ID of the process you are tracing.
"###,
            provider = provider_name,
            probe = probe_name
        );

        // Note that we don't put an #[allow(dead_code)] attribute on the original method, because
        // the user declared that method.  If it's not being used, let the compiler warn them about
        // it just like it would any other unused method.  The methods we generate, however, won't
        // be directly visible to the user and thus should not cause a warning if left un-called
        Ok(quote_spanned! { original_method.span() =>
                                                            #(#attrs)*
                #[doc = "# Probing

This method is translated at compile-time by `probers` into a platform-specific tracing
probe, which allows very high-performance and low-overhead tracing.

## How to fire probe

"]
                                        #[doc = #probe_fire_comment]
        #[doc = "
The exact details of how to interact with the probes depends on the underlying
probing implementation.

## SystemTap/USDT (Linux x64)
"]
                                        #[doc = #systemtap_comment]
        #[doc ="
## Other platforms

TODO: No other platforms supported yet
"]
                                                            #[deprecated(note = #deprecation_message)]
                                                            #[allow(dead_code)]
                                                            #vis #original_method {
                                                                if let Some(probes) = #struct_type_path::get() {
                                                                    if probes.#probe_ident.is_enabled() {
                                                                        probes.#probe_ident.fire(#probe_args_tuple)
                                                                    }
                                                                };
                                                            }

                                                            #[allow(dead_code)]
                                                            #[doc(hidden)]
                                                            #vis #enabled_method -> bool {
                                                                if let Some(probes) = #struct_type_path::get() {
                                                                    probes.#probe_ident.is_enabled()
                                                                } else {
                                                                    false
                                                                }
                                                            }

                                                            #[doc(hidden)]
                                                            #vis #probe_method -> Option<&'static #probe_method_ret_type> {
                                                                #struct_type_path::get().map(|probes| &probes.#probe_ident)
                                                            }
                                                        })
    }

    /// When building a provider, individual probes are added by calling `add_probe` on the
    /// `ProviderBuilder` implementation.  This method generates that call for this probe.  In this
    /// usage the lifetime parameters are not needed.
    pub(crate) fn generate_add_probe_call(&self, builder: &Ident) -> TokenStream {
        //The `add_probe` method takes one type parameter, which should be the tuple form of the
        //arguments for this probe.
        let args_type = self.args_as_tuple_type_with_lifetimes();
        let probe_name = &self.spec.name;

        quote_spanned! { self.spec.original_method.span() =>
            #builder.add_probe::<#args_type>(#probe_name)?;
        }
    }

    /// Each probe has a corresponding field in the struct that we build for the provider.  That
    /// field is an instance of `ProviderProbe` which is a type-safe wrapper around the underlying
    /// untyped implementation.  Because it's type safe it must necessarily have type parameters
    /// corresponding to the arguments to the probe.  Thus its declaration gets a bit complicated.
    ///
    /// Further complicating matters is that the lifetime elision that makes it so easy to declare
    /// functions with reference args isn't available here, so every reference parameter the probe
    /// takes needs to have a corresponding lifetime.  This gets messy, as you'll see.
    pub(crate) fn generate_provider_probe_type(&self) -> TokenStream {
        let arg_tuple = self.args_as_tuple_type_with_lifetimes();

        //In addition to the lifetime params for any ref args, all `ProviderProbe`s have a lifetime
        //param 'a which corresponds to the lifetime of the underlying `UnsafeProviderProbeImpl`
        //which they wrap.  That is the same for all probes, so we just hard-code it as 'a
        let a_lifetime = syn::Lifetime::new("'a", self.spec.span);

        quote_spanned! { self.spec.span =>
            ::probers::ProviderProbe<#a_lifetime, ::probers::SystemProbe, #arg_tuple>
        }
    }

    /// Generates the declaration of the member field within the provider implementation struct
    /// that holds the `ProviderProbe` instance for this probe.  It's a complex declaration because
    /// it must include lifetime parameters for all of the reference types used by any of this
    /// probe's arguments
    pub(crate) fn generate_struct_member_declaration(&self) -> TokenStream {
        let name = self.probe_var_name();
        let typ = self.generate_provider_probe_type();

        quote_spanned! { self.spec.span =>
            #name: #typ
        }
    }

    /// When we create a new instance of the struct which represents the provider and holds the
    /// `ProviderProbe` objects for all of the probes, each of those members needs to be
    /// initialized as part of the initialization expression for the struct.  This method generates
    /// the initialization expression for just this probe.
    ///
    /// For the whole struct it would look something like:
    ///
    /// ```noexecute
    /// FooProviderImpl{
    ///     probe1: provider.probe::<(i32,)>("probe1")?,
    ///     probe2: provider.probe::<(&str,&str,)>("probe2")?,
    ///     ...
    /// }
    /// ```
    ///
    /// This method generates just the line corresponding to this probe, without a trailing comma.
    pub(crate) fn generate_struct_member_initialization(&self, provider: &Ident) -> TokenStream {
        let name_literal = &self.spec.name;
        let name_ident = &self.spec.method_name;
        let args_tuple = self.args_as_tuple_type_without_lifetimes();

        quote_spanned! { self.spec.span =>
            #name_ident: #provider.get_probe::<#args_tuple>(#name_literal)?
        }
    }

    /// Gets all of the lifetime parameters for all of the reference args for this probe, in a
    /// `Vec` for convenient post-processing.
    ///
    /// For example:
    ///
    /// ```noexecute
    /// fn probe(arg0: &str, arg1: usize, arg2: Option<Result<(), &String>>;
    ///
    /// // results in vec!['probe_arg0_1, 'probe_arg2, _1]
    /// ```
    pub(crate) fn args_lifetime_parameters(&self) -> Vec<syn::Lifetime> {
        self.spec
            .args
            .iter()
            .map(|arg| arg.lifetimes())
            .flatten()
            .collect::<Vec<syn::Lifetime>>()
    }

    /// Build a tuple value expression, consisting of the names of the probe arguments in a tuple.
    /// For example:
    ///
    /// ```noexecute
    /// fn probe(arg0: &str, arg1: usize); //results in tuple: (arg0, arg1,)
    /// ```
    pub(crate) fn args_as_tuple_value(&self) -> TokenStream {
        let names = self.spec.args.iter().map(|arg| arg.ident());

        if self.spec.args.is_empty() {
            quote! { () }
        } else {
            quote_spanned! { self.spec.original_method.sig.decl.inputs.span() =>
                ( #(#names),* ,)
            }
        }
    }

    /// Build a tuple type expression whose elements correspond to the arguments of this probe.
    /// This includes only the type of each argument, and has no explicit lifetimes specified.  For
    /// that there is `args_as_tuple_type_with_lifetimes`
    pub(crate) fn args_as_tuple_type_without_lifetimes(&self) -> TokenStream {
        //When the probe spec is constructed lifetime parameters are added, so to construct a tuple
        //type without them they need to be stripped
        if self.spec.args.is_empty() {
            quote_spanned! { self.spec.span => () }
        } else {
            // Build alist of all of the arg types, but use the version without lifetimes
            let args = self.spec.args.iter().map(|arg| arg.syn_typ());

            //Now make a tuple type with the types
            quote_spanned! { self.spec.span =>
                ( #(#args),* ,)
            }
        }
    }

    /// Like the method above constructs a tuple type corresponding to the types of the arguments of this probe.
    ///  Unlike the above method, this tuple type is also annotated with explicit lifetime
    ///  parameters for all reference types in the tuple.
    pub(crate) fn args_as_tuple_type_with_lifetimes(&self) -> TokenStream {
        // same as the above method, but use the version with lifetime annotations
        let types = self
            .spec
            .args
            .iter()
            .map(|arg| arg.syn_typ_with_lifetimes());

        if self.spec.args.is_empty() {
            quote! { () }
        } else {
            quote_spanned! { self.spec.original_method.sig.decl.inputs.span() =>
                ( #(#types),* ,)
            }
        }
    }
}

/// It's quite difficult to meaningfully test code generators that use the `quote` crate.  These
/// tests exercise the code with various test cases, and verify that the generator doesn't fail or
/// panic.  But they do not verify that the generated code will compile.
///
/// The integration tests and examples in the `probe-rs` parent crate do that.
#[cfg(test)]
mod test {
    use super::*;
    use crate::testdata;

    #[test]
    fn generate_works_on_valid_traits() {
        for test_case in testdata::get_test_provider_traits(|c: &testdata::TestProviderTrait| {
            c.expected_error.is_none()
        })
        .into_iter()
        {
            let item_trait = test_case.get_item_trait();
            let spec = ProviderSpecification::from_trait(&item_trait).expect(&format!(
                "Failed to create specification from test trait '{}'",
                test_case.description
            ));

            let generator = ProviderTraitGenerator::new(&spec);
            generator.generate().expect(&format!(
                "Failed to generate test trait '{}'",
                test_case.description
            ));
        }
    }
}
