//! This module is where the *implementation* of the probe-related proc macros are.  The actual
//! proc macro is in the `probers-macros` crate because proc macro crates can _only_ export proc
//! macros and nothing else.  That's an inconvenient restriction, especially since there's quite a
//! lot of overlap between the macro code and the build-time probe code generation logic.  Hence,
//! this bifurcation.
use crate::probe;
use crate::provider;
use crate::provider::ProviderSpecification;
use crate::{ProberError, ProberResult};
use heck::{ShoutySnakeCase, SnakeCase};
use proc_macro2::TokenStream;
use quote::{quote, quote_spanned};
use std::borrow::BorrowMut;
use std::fmt::Display;
use syn::parse_quote;
use syn::spanned::Spanned;
use syn::{Ident, ItemTrait};

use crate::{CodeGenerator, Generator};

/// Uses the `syn` library's `Error` struct to report an error in the form of a `TokenStream`, so
/// that a proc macro can insert this token stream into its output and thereby report a detailed
/// error message to the user.
///
/// The span of this error corresponds to the `tokens` parameter, so the user gets the relevant
/// context for the error
pub fn report_error<T: quote::ToTokens, U: Display>(tokens: &T, message: U) -> TokenStream {
    syn::Error::new_spanned(tokens.clone(), message).to_compile_error()
}

/// Translates what looks to be an explicit call to the associated function corresponding to a
/// probe on a provider trait, into something which at runtime will most efficiently attempt to
/// access the global static instance of the probe and, if it's enabled, evaluate the args and fire
/// the probe.
///
/// It translates something like this:
///
/// ```noexecute
/// probe!(MyProvider::myprobe(1, 5, "this is a string", compute_something()));
/// ```
///
/// into:
///
/// ```noexecute
/// {
///     if let Some(probe) = MyProvider::get_myprobe_probe() {
///         if probe.is_enabled() {
///             probe.fire((1, 5, "this is a string", compute_something(),)));
///         }
///     }
/// }
/// ```
///
/// In particular, note that the probe's parameters are not evaluated unless the provider
/// initialized successfully and the probe is enabled.
pub fn probe_impl(call: syn::Expr) -> ProberResult<TokenStream> {
    match call {
        syn::Expr::Call(call) => {
            //Using this call to the probe method as the starting point, modify it so that instead
            //of calling `(probename)` we call `get_(probename)_probe`, which will have been
            //generated by the `probers` proc macro
            let mut get_probe_call = call.clone();

            if let syn::Expr::Path(ref mut func) = get_probe_call.func.borrow_mut() {
                if let Some(ref mut pair) = func.path.segments.last_mut() {
                    let mut probe_segment = pair.value_mut();
                    probe_segment.ident = Ident::new(
                        &format!("get_{}_probe", probe_segment.ident),
                        probe_segment.ident.span(),
                    );
                }

                //the `get_(probename)_probe` method will not be taking any arguments; instead
                //those arguments should be used when calling the `fire` method
                let fire_args = syn::Expr::Tuple(syn::ExprTuple {
                    attrs: Vec::new(),
                    paren_token: get_probe_call.paren_token.clone(),
                    elems: get_probe_call.args,
                });
                get_probe_call.args = syn::punctuated::Punctuated::new();

                Ok(quote_spanned! { call.span() =>
                    {
                        if let Some(__probers_probe) = #get_probe_call {
                            if __probers_probe.is_enabled() {
                                __probers_probe.fire(#fire_args);
                            }
                        }
                    }
                })
            } else {
                return Err(ProberError::new(
                    format!("Unexpected expression for function call: {:?}", call.func),
                    call.span(),
                ));
            }
        }
        _ => {
            return Err(ProberError::new(
                    "The probe! macro requires the name of a provider trait and its probe method, e.g. MyProvider::myprobe(...)",
                    call.span(),
                    ));
        }
    }
}

pub fn init_provider_impl(typ: syn::TypePath) -> ProberResult<TokenStream> {
    Ok(quote_spanned! { typ.span() =>
        #typ::__try_init_provider()
    })
}

/// Actual implementation of the macro logic, factored out of the proc macro itself so that it's
/// more testable
pub fn prober_impl(item: ItemTrait) -> ProberResult<TokenStream> {
    Generator::handle_provider_trait(&item)
}

#[cfg(test)]
mod test {}
